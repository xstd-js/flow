import { sleep } from '@xstd/abortable';
import { describe, test } from 'vitest';
import { WebSocketFlow } from './built-in/web-socket/web-socket-flow.js';
import { Drain } from './drain/drain.js';
import { inspectFlow } from './flow/readable/helpers/inspect-flow.js';
import { ReadableFlow } from './flow/readable/readable-flow.js';
import { FlowReader } from './flow/readable/types/flow-reader.js';
import { ReadableFlowContext } from './flow/readable/types/readable-flow-context.js';

/*--------*/

/*-------------*/

async function debugFlow00() {
  const a = async function* (this: any) {
    console.log(this);
    yield 1;
    console.log(this);
  };

  const it = a();
  // const it = a.call({ a: 1 });
  for await (const i of it) {
    console.log(i);
  }
}

async function debugFlow001() {
  // const a = writableGenerator<[], number, boolean, string>(
  //   function* (): WritableGeneratorInFunctionReturn<number, boolean, string> {
  //     console.log('yield 1', yield true);
  //     console.log('yield 2', yield false);
  //     console.log('yield 3', yield true);
  //     console.log('yield 4', yield false);
  //
  //     return 'a';
  //   },
  // );
  //
  // const it = a();
  // console.log('next 0', it.next(0));
  // console.log('next 1', it.next(1));
  // console.log('return - 0', it.return());
  // // it.throw('ok');
  // console.log('next 2', it.next(2));
  // console.log('next 3', it.next(3));
}

async function debugFlow002() {
  const a = async function* () {
    await sleep(200);
    yield 0;
    yield 1;
    yield 2;
  };

  // const it: AsyncIterable<number> = {
  //   [Symbol.asyncIterator](): AsyncIterator<number> {
  //     return {
  //       async next(): Promise<IteratorResult<number>> {
  //         return {
  //           done: false,
  //           value: 0,
  //         };
  //       },
  //       async throw(error?: unknown): Promise<IteratorResult<number>> {
  //         console.log('error', error);
  //         return {
  //           done: true,
  //           value: undefined,
  //         };
  //       },
  //       async return(value: any): Promise<IteratorResult<number>> {
  //         console.log('return', value);
  //         return {
  //           done: true,
  //           value,
  //         };
  //       },
  //     };
  //   },
  // };

  const it: AsyncGenerator<number> = a();
  console.log(await it.return(undefined));
  console.log(await it.return(undefined));

  // console.log(await it.next());
  // try {
  //   console.log(await it.throw('abc'));
  // } catch (error: unknown) {
  //   console.log(error);
  // }
  // // console.log(await it.throw('def'));
  // console.log(await it.next());

  // try {
  //   console.log(await it.next());
  //   console.log(await it.next());
  //   console.log(await it.next());
  // } catch (error: unknown) {
  //   console.log(error);
  // }
  // // console.log(await it.throw('def'));
  // console.log(await it.next());

  // console.log(await Promise.all([it.next(), it.return(undefined), it.next()]));

  // for await (const i of it) {
  //   console.log(i);
  //   // return;
  //   throw 'e';
  // }
}

async function debugFlow01() {
  const controller = new AbortController();

  const flowA = new ReadableFlow<number>(async function* () {
    // yield* Flow.fromIterable([0, 1, 2]).open(signal);
    try {
      yield* [0, 1, 2];
    } finally {
      console.log('flowA done');
    }
  });

  const flowB = new ReadableFlow<number>(async function* (ctx: ReadableFlowContext) {
    try {
      yield* flowA.use(ctx);
      yield 3;
    } finally {
      console.log('flowB done');
    }
  })
    // .map((i) => i * 2)
    // .filter((i) => i > 2);
    // .take(1);
    // .drop(1);
    .inspect(inspectFlow('flowB'));

  // const a = flowA.open(controller.signal);
  // console.log(await a.next());
  // controller.abort('abc');
  // console.log(await a.next());
  // console.log(await a.throw('ok'));
  // await sleep(500);

  for await (const i of flowB.open(controller.signal)) {
    console.log(i);
    controller.abort('abc');
    // return;
  }
}

async function debugFlow02() {
  const controller = new AbortController();

  const flowA = new ReadableFlow<number>(async function* ({ signal }: ReadableFlowContext) {
    for (let i: number = 0; i < 4; i++) {
      signal.throwIfAborted();
      yield i;
      await sleep(100, { signal });
    }
  }).inspect(inspectFlow('flowA'));

  const flowB = flowA
    .map((_) => _ * 2)
    .inspect(inspectFlow('flowB'))
    .fork();
  const flowC = flowB
    .map((_) => _ / 4)
    .inspect(inspectFlow('flowC'))
    .fork();

  await Promise.allSettled([
    // (async () => {
    //   for await (const i of flowA.open(controller.signal, { mode: 'fork' })) {
    //     console.log('flowA', i);
    //   }
    // })(),
    (async () => {
      for await (const i of flowB.open(controller.signal)) {
        console.log('flowB', i);
      }
    })(),
    // (async () => {
    //   for await (const i of flowB.open(controller.signal, { mode: 'fork' })) {
    //     console.log('flowB', i);
    //   }
    // })(),
    (async () => {
      await sleep(250, { signal: controller.signal });
      for await (const i of flowC.open(controller.signal)) {
        console.log('flowC', i);
      }
    })(),
    // (async () => {
    //   await sleep(150, controller.signal);
    //   controller.abort();
    // })(),
  ]);

  // for await (const i of flowB.open({ mode: 'fork' })) {
  //   console.log('flowB->', i);
  // }

  console.log('done');
}

async function debugFlow03() {
  const controller = new AbortController();

  const ws = new WebSocketFlow('wss://echo.websocket.org/');

  await Promise.allSettled([
    (async () => {
      for await (const i of ws.down.open(controller.signal)) {
        console.log('down', i);
      }
    })(),
    (async () => {
      await ws.up.drain(
        new ReadableFlow(async function* () {
          while (true) {
            const message: string = new Date().toISOString();
            console.log('sending: ', message);
            yield message;
            await sleep(1000, { signal: controller.signal });
          }
        }),
        controller.signal,
      );
    })(),
    (async () => {
      await sleep(3000, { signal: controller.signal });
      controller.abort();
    })(),
  ]);

  console.log('done');
}

/*---------*/

export interface EntityProperty<GValue> {
  readonly down: FlowReader<GValue>;
  readonly up: Drain<GValue>;
}

export interface EntityEvent<GValue> {
  readonly down: FlowReader<GValue>;
}

/*---------*/

export async function debugFlow() {
  // await debugFlow00();
  // await debugFlow001();
  // await debugFlow002();
  // await debugFlow01();
  // await debugFlow02();
  await debugFlow03();
}

describe('debug-flow', () => {
  globalThis.reportError = (error: unknown): void => {
    console.error(error);
  };

  test('debug', async () => {
    await debugFlow();
  });
});
