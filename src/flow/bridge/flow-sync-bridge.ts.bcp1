import { abortify } from '@xstd/abortable';
import { NONE, type None } from '@xstd/none';
import { FullQueueController } from '../../shared/queue-controller/classic/build-in/full-queue-controller.js';
import { type HavingQueuingStrategy } from '../../shared/queue-controller/classic/having-queuing-strategy.js';
import { type QueueController } from '../../shared/queue-controller/classic/queue-controller.js';
import { type FlowReader } from '../readable/types/flow-reader.js';

/*------*/

type FlowSyncBridgePushState = 'active' | 'errored' | 'complete';
type FlowSyncBridgePullState = 'active' | 'errored' | 'complete';

/*------*/

export interface FlowSyncBridgeOptions extends HavingQueuingStrategy {}

export interface FlowSyncBridge<GValue> {
  write(value: GValue): void;

  error(error?: unknown): void;

  complete(): void;
}

export type FlowSyncBridgeResult<GValue> = readonly [
  bridge: FlowSyncBridge<GValue>,
  reader: FlowReader<GValue>,
];

/*------*/

export function flowSyncBridge<GValue>(
  signal: AbortSignal,
  { queuingStrategy = FullQueueController.factory }: FlowSyncBridgeOptions = {},
): FlowSyncBridgeResult<GValue> {
  const queue: QueueController<GValue> = queuingStrategy();

  let pendingRead: PromiseWithResolvers<void> | undefined;

  let pushState: FlowSyncBridgePushState = 'active';
  let pushError: unknown;
  let pullState: FlowSyncBridgePullState = 'active';

  const isActive = (): boolean => {
    return pushState === 'active' && pullState === 'active';
  };

  const throwIfNotActive = (): void => {
    if (!isActive()) {
      throw new Error('The bridge is not active.');
    }
  };

  const resolvePendingRead = (): void => {
    if (pendingRead !== undefined) {
      pendingRead.resolve();
      pendingRead = undefined;
    }
  };

  return [
    {
      write: (value: GValue): void => {
        throwIfNotActive();

        queue.push(value);

        resolvePendingRead();
      },
      error: (error?: unknown): void => {
        throwIfNotActive();

        pushState = 'errored';
        pushError = error;

        resolvePendingRead();
      },
      complete: (): void => {
        throwIfNotActive();

        pushState = 'complete';

        resolvePendingRead();
      },
    },
    (async function* (): AsyncGenerator<GValue, void, void> {
      try {
        while (true) {
          signal.throwIfAborted();

          if (pushState === 'active') {
            const value: GValue | None = queue.pull();

            if (value === NONE) {
              // create a promise for the reader that resolves on the next write, and wait for its resolution
              await abortify((pendingRead = Promise.withResolvers<void>()).promise, { signal });
            } else {
              yield value;
            }
          } else if (pushState === 'errored') {
            throw pushError;
          } /* if (pushState === 'complete') */ else {
            return;
          }
        }
      } catch (error: unknown) {
        pullState = 'errored';
        throw error;
      } finally {
        if (pullState === 'active') {
          pullState = 'complete';
        }
      }
    })(),
  ];
}
