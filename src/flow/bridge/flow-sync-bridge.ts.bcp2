import { abortify } from '@xstd/abortable';
import { NONE, type None } from '@xstd/none';

import { type IteratorStep } from '../../enumerable/iterator-step.js';
import { CountQueue } from '../../shared/queue-controller/classic/build-in/count-queue.js';
import { type GenericQueue } from '../../shared/queue-controller/classic/generic-queue.js';
import { type HavingQueuingStrategy } from '../../shared/queue/push-to-pull/having-queuing-strategy.js';
import { type FlowReader } from '../readable/types/flow-reader.js';

/*------*/

export interface FlowSyncBridgeOptions extends HavingQueuingStrategy {}

export interface FlowSyncBridge<GValue> {
  next(value: GValue): void;

  error(error?: unknown): void;

  complete(): void;
}

export type FlowSyncBridgeResult<GValue> = readonly [
  bridge: FlowSyncBridge<GValue>,
  reader: FlowReader<GValue>,
];

/*------*/

export function flowSyncBridge<GValue>(
  signal: AbortSignal,
  { queuingStrategy = CountQueue.zero }: FlowSyncBridgeOptions = {},
): FlowSyncBridgeResult<GValue> {
  const queue: GenericQueue<IteratorStep<GValue>> = queuingStrategy<IteratorStep<GValue>>();

  let iteratorStepPromise: PromiseWithResolvers<IteratorStep<GValue>> | undefined;
  let done: boolean = false;

  const step = (step: IteratorStep<GValue>): void => {
    if (done) {
      throw new Error('Bridge already closed.');
    }

    queue.push(step);

    if (iteratorStepPromise !== undefined) {
      iteratorStepPromise.resolve(step);
      iteratorStepPromise = undefined;
    }
  };

  return [
    {
      next: (value: GValue): void => {
        step({
          type: 'next',
          value,
        });
      },
      error: (error?: unknown): void => {
        step({
          type: 'error',
          error,
        });
      },
      complete: (): void => {
        step({
          type: 'complete',
        });
      },
    },
    (async function* (): AsyncGenerator<GValue, void, void> {
      try {
        let iteratorStep: IteratorStep<GValue> | undefined;

        while (true) {
          signal.throwIfAborted();

          let cachedIteratorStep: IteratorStep<GValue> | None;
          // dequeue the steps of the queue that have already been treated
          while ((cachedIteratorStep = queue.pull()) === iteratorStep);

          if (cachedIteratorStep === NONE) {
            iteratorStep = await abortify(
              (iteratorStepPromise = Promise.withResolvers<IteratorStep<GValue>>()).promise,
              {
                signal,
              },
            );
          } else {
            iteratorStep = cachedIteratorStep;
          }

          if (iteratorStep.type === 'next') {
            yield iteratorStep.value;
          } else if (iteratorStep.type === 'error') {
            throw iteratorStep.error;
          } else {
            return;
          }
        }
      } finally {
        done = true;
      }
    })(),
  ];
}
