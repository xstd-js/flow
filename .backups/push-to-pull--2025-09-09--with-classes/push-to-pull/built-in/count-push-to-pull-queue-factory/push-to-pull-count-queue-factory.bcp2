import { abortify } from '@xstd/abortable';
import { NONE, type None } from '@xstd/none';
import { type IteratorStep } from '../../../../../enumerable/iterator-step.js';
import { PullQueue } from '../../pull-queue.js';
import { PushQueue } from '../../push-queue.js';
import { PushToPullQueueFactory } from '../../push-to-pull-queue-factory.js';
import { PushToPullQueue } from '../../push-to-pull-queue.js';

export class PushToPullCountQueueFactory<GValue> extends PushToPullQueueFactory<GValue> {
  static #zero: PushToPullQueueFactory<any>;

  static zero<GValue = any>(): PushToPullQueueFactory<GValue> {
    if (this.#zero === undefined) {
      this.#zero = new PushToPullCountQueueFactory<any>(0);
    }
    return this.#zero;
  }

  static #one: PushToPullQueueFactory<any>;

  static one<GValue = any>(): PushToPullQueueFactory<GValue> {
    if (this.#one === undefined) {
      this.#one = new PushToPullCountQueueFactory<any>(1);
    }
    return this.#one;
  }

  static #infinity: PushToPullQueueFactory<any>;

  static infinity<GValue = any>(): PushToPullQueueFactory<GValue> {
    if (this.#infinity === undefined) {
      this.#infinity = new PushToPullCountQueueFactory<any>(Number.POSITIVE_INFINITY);
    }
    return this.#infinity;
  }

  readonly #count: number;

  constructor(count: number) {
    super((signal: AbortSignal): PushToPullQueue<GValue> => {
      const queue: IteratorStep<GValue>[] = [];
      let iteratorStepPromise: PromiseWithResolvers<IteratorStep<GValue>> | undefined;
      let done: boolean = false;

      const push = (value: IteratorStep<GValue>): void => {
        queue.push(value);

        if (queue.length > this.#count) {
          queue.shift();
        }
      };

      const pull = (): IteratorStep<GValue> | None => {
        if (queue.length === 0) {
          return NONE;
        } else {
          return queue.shift()!;
        }
      };

      const step = (step: IteratorStep<GValue>): void => {
        if (done) {
          throw new Error('Queue closed.');
        }

        push(step);

        if (iteratorStepPromise !== undefined) {
          iteratorStepPromise.resolve(step);
          iteratorStepPromise = undefined;
        }
      };

      return new PushToPullQueue<GValue>({
        push: new PushQueue<GValue>({
          next: (value: GValue): void => {
            step({
              type: 'next',
              value,
            });
          },
          error: (error?: unknown): void => {
            step({
              type: 'error',
              error,
            });
          },
          complete: (): void => {
            step({
              type: 'complete',
            });
          },
        }),
        pull: new PullQueue<GValue>(
          (async function* (): AsyncGenerator<GValue, void, void> {
            try {
              let iteratorStep: IteratorStep<GValue> | undefined;

              while (true) {
                signal.throwIfAborted();

                let cachedIteratorStep: IteratorStep<GValue> | None;
                // dequeue the steps of the queue that have already been treated
                while ((cachedIteratorStep = pull()) === iteratorStep);

                if (cachedIteratorStep === NONE) {
                  iteratorStep = await abortify(
                    (iteratorStepPromise = Promise.withResolvers<IteratorStep<GValue>>()).promise,
                    {
                      signal,
                    },
                  );
                } else {
                  iteratorStep = cachedIteratorStep;
                }

                if (iteratorStep.type === 'next') {
                  yield iteratorStep.value;
                } else if (iteratorStep.type === 'error') {
                  throw iteratorStep.error;
                } else {
                  return;
                }
              }
            } finally {
              done = true;
            }
          })(),
        ),
      });
    });

    this.#count = Math.max(0, count);
  }
}
